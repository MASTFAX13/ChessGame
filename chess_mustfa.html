<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ø´Ø·Ø±Ù†Ø¬ Ù…ØµØ·ÙÙ‰ - Ø§Ù„Ù„Ø¹Ø¨Ø© Ø§Ù„Ø£Ø³Ø·ÙˆØ±ÙŠØ©</title>
  <!-- Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª PWA -->
  <meta name="theme-color" content="#2d2d2d">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <!-- ØªØ¶Ù…ÙŠÙ† manifest Ø¹Ø¨Ø± data URI (ÙŠÙ…ÙƒÙ† ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø£ÙŠÙ‚ÙˆÙ†Ø© Ù„Ø§Ø­Ù‚Ø§Ù‹) -->
  <link rel="manifest" href="data:application/manifest+json,%7B%22name%22%3A%22%D8%B4%D8%B7%D8%B1%D9%86%D8%AC%20%D9%85%D8%B5%D8%B7%D9%81%D9%89%22%2C%22short_name%22%3A%22%D8%B4%D8%B7%D8%B1%D9%86%D8%AC%22%2C%22start_url%22%3A%22.%22%2C%22display%22%3A%22standalone%22%2C%22background_color%22%3A%22%232d2d2d%22%2C%22theme_color%22%3A%22%232d2d2d%22%2C%22icons%22%3A%5B%7B%22src%22%3A%22data%3Aimage%2Fpng%3Bbase64%2CiVBORw0KGgoAAAANSUhEUgAAAMgAAADICAMAAACahl6sAAAAA1BMVEX%2F%2F%2F%2F%2F%2FnxBvIAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAKUlEQVR4nO3BMQEAAADCoPdPbQ8HFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPwLwjMAAXEoIQAAAAAElFTkSuQmCC%22%2C%22sizes%22%3A%22192x192%22%2C%22type%22%3A%22image%2Fpng%22%7D%5D%7D">
  <!-- Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø®Ø· "Cairo" Ù„Ø¯Ø¹Ù… Ø§Ù„ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© -->
  <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;700&display=swap" rel="stylesheet">
  <style>
    /* Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© */
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: 'Cairo', sans-serif;
      /* Ø®Ù„ÙÙŠØ© Ù‡Ø§Ø¯Ø¦Ø© Ù…ØªÙ†Ø§Ø³Ù‚Ø© Ù…Ø¹ Ù„ÙˆØ­Ø© Ø§Ù„Ø´Ø·Ø±Ù†Ø¬ */
      background: linear-gradient(135deg, #2d2d2d, #1a1a1a);
      color: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px;
      min-height: 100vh;
      transition: background 0.5s;
    }
    header {
      width: 100%;
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      flex-wrap: wrap;
    }
    header h1 {
      font-size: 28px;
      margin: 5px;
    }
    .header-buttons {
      display: flex;
      gap: 10px;
      margin: 5px;
    }
    button {
      padding: 8px 12px;
      font-size: 16px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: transform 0.2s, background-color 0.2s;
    }
    button:hover { transform: scale(1.05); }
    /* Ø£Ø²Ø±Ø§Ø± Ø§Ù„ØªØ­ÙƒÙ… */
    #menuButton, #installButton, .control-btn {
      background: #e67e22;
      color: #fff;
    }
    #soundToggle, #musicToggle, #themeToggle {
      background: #2980b9;
      color: #fff;
    }
    #turnIndicator, #timer, #statusBar {
      margin: 8px;
      font-size: 20px;
      text-align: center;
      width: 100%;
    }
    /* Ø§Ù„Ù„ÙˆØ­Ø©: Ø­Ø¬Ù… Ø«Ø§Ø¨Øª 560Ã—560 Ø¨ÙƒØ³Ù„ */
    .board {
      position: relative;
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      grid-template-rows: repeat(8, 1fr);
      width: 560px;
      height: 560px;
      border: 3px solid #34495e;
      box-shadow: 0 0 15px rgba(0,0,0,0.5);
      margin-bottom: 15px;
      border-radius: 8px;
      /* Ø¥Ø²Ø§Ù„Ø© overflow Ù„Ø¶Ù…Ø§Ù† Ø¸Ù‡ÙˆØ± ÙƒÙ„ Ø§Ù„Ø®Ø§Ù†Ø§Øª */
    }
    /* Ø¥Ø¶Ø§ÙØ© Ø¹Ù„Ø§Ù…Ø© Ù…Ø§Ø¦ÙŠØ© (Watermark) Ø¹Ù„Ù‰ Ø§Ù„Ù„ÙˆØ­Ø© */
    .board::after {
      content: "Ø­Ù‚ÙˆÙ‚ Ø§Ù„ØªØµÙ…ÙŠÙ… Â© Ù…ØµØ·ÙÙ‰";
      position: absolute;
      bottom: 5px;
      right: 5px;
      font-size: 10px;
      color: rgba(0,0,0,0.3);
      pointer-events: none;
    }
    .cell {
      position: relative;
      /* ÙƒÙ„ Ø®Ø§Ù†Ø© ØªØ£Ø®Ø° Ù†Ø³Ø¨Ø© 100% Ù…Ù† Ù…Ø³Ø§Ø­Ø© Ø®Ù„ÙŠØ© Ø§Ù„Ø´Ø¨ÙƒØ© */
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 32px;
      cursor: pointer;
      transition: background-color 0.2s, transform 0.2s;
      user-select: none;
    }
    .cell:hover { transform: scale(1.05); }
    .white { background-color: #f0d9b5; color: #000; }
    .black { background-color: #b58863; color: #000; }
    .selected { background-color: #7BA23F !important; }
    .valid-move::after {
      content: '';
      width: 20px;
      height: 20px;
      background: rgba(39,174,96,0.5);
      border-radius: 50%;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
      margin-bottom: 15px;
      width: 100%;
      max-width: 560px;
    }
    .info-panel {
      width: 100%;
      max-width: 560px;
      background: rgba(0,0,0,0.4);
      padding: 10px;
      border-radius: 10px;
      margin-bottom: 10px;
    }
    .info-panel h3 { margin-bottom: 5px; text-align: center; }
    .move-history {
      max-height: 150px;
      overflow-y: auto;
      background: rgba(255,255,255,0.1);
      padding: 5px;
      border-radius: 5px;
    }
    .move-history p { margin: 2px 0; font-size: 16px; }
    /* Ø´Ø§Ø´Ø§Øª Overlay (Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©ØŒ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©ØŒ Ø§Ù„ØªØ¹Ù„ÙŠÙ…Ø§Øª) */
    .overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.85);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      animation: fadeIn 0.3s ease-in-out;
    }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    .modal-container {
      background: #34495e;
      padding: 20px;
      border-radius: 10px;
      text-align: center;
      width: 90%;
      max-width: 350px;
    }
    .modal-container input {
      padding: 10px;
      margin: 10px 0;
      width: 90%;
      font-size: 16px;
      border-radius: 5px;
      border: none;
    }
    /* Ø´Ø±ÙŠØ· Ø§Ù„ØªÙ‚Ø¯Ù… Ù„Ù„Ù…Ø¤Ù‚Øª */
    .progress-bar {
      width: 100%;
      background: #ddd;
      border-radius: 5px;
      overflow: hidden;
      margin: 5px 0;
    }
    .progress-fill {
      height: 10px;
      background: #27ae60;
      width: 100%;
      transition: width 0.5s;
    }
    /* ØªØ°ÙŠÙŠÙ„ Ø­Ù‚ÙˆÙ‚ Ø§Ù„Ù†Ø´Ø± */
    footer {
      margin-top: 10px;
      font-size: 14px;
      color: #ccc;
    }
  </style>
</head>
<body>
  <!-- Ù…Ù†Ø¹ Ø§Ù„Ù†Ù‚Ø± Ø¨Ø²Ø± Ø§Ù„ÙØ£Ø±Ø© Ø§Ù„Ø£ÙŠÙ…Ù† Ù„Ø­Ù…Ø§ÙŠØ© Ø§Ù„ÙƒÙˆØ¯ -->
  <script>document.addEventListener('contextmenu', event => event.preventDefault());</script>
  <!-- Ø§Ù„Ø±Ø£Ø³ (Header) Ù…Ø¹ Ø§Ù„Ø¹Ù†ÙˆØ§Ù† ÙˆØ£Ø²Ø±Ø§Ø± Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª -->
  <header>
    <h1>ğŸ® Ø´Ø·Ø±Ù†Ø¬ Ù…ØµØ·ÙÙ‰</h1>
    <div class="header-buttons">
      <button id="menuButton" onclick="openMenu()">Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©</button>
      <button id="installButton" onclick="installApp()">ØªØ«Ø¨ÙŠØª Ø§Ù„ØªØ·Ø¨ÙŠÙ‚</button>
      <button id="soundToggle" onclick="toggleSound()">ØµÙˆØª: ØªØ´ØºÙŠÙ„</button>
      <button id="musicToggle" onclick="toggleMusic()">Ù…ÙˆØ³ÙŠÙ‚Ù‰: ØªØ´ØºÙŠÙ„</button>
      <button id="themeToggle" onclick="toggleTheme()">Ø«ÙŠÙ…: Ø¯Ø§ÙƒÙ†</button>
    </div>
  </header>
  <div id="turnIndicator"></div>
  <div id="timer"></div>
  <div class="progress-bar"><div id="timerProgress" class="progress-fill"></div></div>
  <div class="board" id="board"></div>
  <div class="controls">
    <button class="control-btn" onclick="resetGame()">Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ´ØºÙŠÙ„</button>
    <button class="control-btn" onclick="undoMove()">ØªØ±Ø§Ø¬Ø¹</button>
    <button class="control-btn" onclick="openHelp()">ØªØ¹Ù„ÙŠÙ…Ø§Øª</button>
  </div>
  <div id="statusBar"></div>
  <div class="info-panel">
    <h3>Ø³Ø¬Ù„ Ø§Ù„Ø­Ø±ÙƒØ§Øª</h3>
    <div class="move-history" id="moveHistory"></div>
  </div>
  <footer>
    Ø­Ù‚ÙˆÙ‚ Ø§Ù„ØªØµÙ…ÙŠÙ… Ù…Ø­ÙÙˆØ¸Ø© Ù„Ù…ØµØ·ÙÙ‰ Â© 2025
  </footer>

  <!-- Ø´Ø§Ø´Ø© Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© Ù„Ø¥Ø¯Ø®Ø§Ù„ Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ† -->
  <div id="startScreen" class="overlay">
    <div class="modal-container">
      <h2>Ø£Ø¯Ø®Ù„ Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ†</h2>
      <input type="text" id="whitePlayerNameInput" placeholder="Ø§Ø³Ù… Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ø£Ø¨ÙŠØ¶" value="Ù…ØµØ·ÙÙ‰">
      <input type="text" id="blackPlayerNameInput" placeholder="Ø§Ø³Ù… Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ø£Ø³ÙˆØ¯" value="Ù„Ø§Ø¹Ø¨ 2">
      <br>
      <button onclick="startGame()">Ø¨Ø¯Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø©</button>
    </div>
  </div>

  <!-- Ø´Ø§Ø´Ø© Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© -->
  <div id="menuScreen" class="overlay" style="display:none;">
    <div class="modal-container">
      <h2>Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©</h2>
      <button onclick="resetGame(); closeMenu();">Ø¨Ø¯Ø¡ Ù„Ø¹Ø¨Ø© Ø¬Ø¯ÙŠØ¯Ø©</button>
      <button onclick="openHelp(); closeMenu();">ØªØ¹Ù„ÙŠÙ…Ø§Øª Ø§Ù„Ù„Ø¹Ø¨Ø©</button>
      <button onclick="closeMenu()">Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©</button>
    </div>
  </div>

  <!-- Ø´Ø§Ø´Ø© Ø§Ù„ØªØ¹Ù„ÙŠÙ…Ø§Øª -->
  <div id="helpScreen" class="overlay" style="display:none;">
    <div class="modal-container">
      <h2>ØªØ¹Ù„ÙŠÙ…Ø§Øª Ø§Ù„Ù„Ø¹Ø¨Ø©</h2>
      <p>Ù…Ø±Ø­Ø¨Ù‹Ø§ Ø¨Ùƒ ÙÙŠ Ù„Ø¹Ø¨Ø© Ø´Ø·Ø±Ù†Ø¬ Ù…ØµØ·ÙÙ‰ Ø§Ù„Ø£Ø³Ø·ÙˆØ±ÙŠØ©!</p>
      <ul style="text-align: right; list-style: decimal; margin: 10px 0; padding-right: 20px;">
        <li>ÙŠÙÙ…Ù†Ø¹ Ø£ÙƒÙ„ Ø§Ù„Ù…Ù„Ùƒ ÙƒÙ‚Ø·Ø¹Ø© Ø¹Ø§Ø¯ÙŠØ©.</li>
        <li>ÙŠØ¯Ø¹Ù… Ø§Ù„ØªØ¨ÙŠÙŠØª Ù…Ø¹ Ù†Ù‚Ù„ Ø§Ù„Ù‚Ù„Ø¹Ø© ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§ Ø¹Ù†Ø¯ Ø§Ø³ØªÙŠÙØ§Ø¡ Ø§Ù„Ø´Ø±ÙˆØ·.</li>
        <li>Ø³Ø¬Ù„ Ø§Ù„Ø­Ø±ÙƒØ§Øª ÙŠØ¸Ù‡Ø± Ø¨Ø§Ù„ØªÙ†Ø³ÙŠÙ‚ (A1 â€“ H8).</li>
        <li>ÙŠÙˆØ¬Ø¯ Ù…Ø¤Ù‚Øª Ù„ÙƒÙ„ Ù„Ø§Ø¹Ø¨ Ù…Ø¹ Ø´Ø±ÙŠØ· ØªÙ‚Ø¯Ù… ÙŠÙØ¸Ù‡Ø± Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ.</li>
        <li>ÙŠÙ…ÙƒÙ† Ø§Ù„ØªØ±Ø§Ø¬Ø¹ Ø¹Ù† Ø¢Ø®Ø± Ø­Ø±ÙƒØ© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø²Ø± "ØªØ±Ø§Ø¬Ø¹".</li>
        <li>ÙŠÙ…ÙƒÙ† ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„ØµÙˆØªØŒ Ø§Ù„Ù…ÙˆØ³ÙŠÙ‚Ù‰ ÙˆØ§Ù„Ø«ÙŠÙ… Ù…Ù† Ø®Ù„Ø§Ù„ Ø§Ù„Ø£Ø²Ø±Ø§Ø±.</li>
        <li>ØªÙ†Ø¨ÙŠÙ‡Ø§Øª Ø¨ØµØ±ÙŠØ© ØªØ¸Ù‡Ø± Ø¹Ù†Ø¯ ØªØ¹Ø±Ø¶ Ø§Ù„Ù…Ù„Ùƒ Ù„Ù„ÙƒØ´.</li>
        <li>ØªØ£Ø«ÙŠØ±Ø§Øª ØµÙˆØªÙŠØ© Ø¹Ù†Ø¯ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù‚Ø·Ø¹Ø© ÙˆØªÙ†ÙÙŠØ° Ø§Ù„Ø­Ø±ÙƒØ©.</li>
        <li>ÙˆØ§Ø¬Ù‡Ø© Ù…ØªØ¬Ø§ÙˆØ¨Ø© ØªØ¹Ù…Ù„ Ø¨ÙƒÙØ§Ø¡Ø© Ø¹Ù„Ù‰ ÙƒØ§ÙØ© Ø§Ù„Ø£Ø¬Ù‡Ø²Ø©.</li>
        <li>Ø¯Ø¹Ù… ØªØ«Ø¨ÙŠØª Ø§Ù„Ù„Ø¹Ø¨Ø© ÙƒØªØ·Ø¨ÙŠÙ‚ ÙˆÙŠØ¨ ØªÙ‚Ø¯Ù…ÙŠ (PWA) â€“ Ù„ØªØ¹Ù…Ù„ Ø¹Ù†Ø¯ Ø±ÙØ¹Ù‡Ø§ Ø¹Ù„Ù‰ Ø®Ø§Ø¯Ù… ÙˆÙŠØ¨ Ø­Ù‚ÙŠÙ‚ÙŠ.</li>
        <li>Ù„ÙØªØ­ Ù…ÙŠØ²Ø© Ø§Ù„ØªØ«Ø¨ÙŠØªØŒ ØªØ£ÙƒØ¯ Ù…Ù† Ø±ÙØ¹ Ø§Ù„Ù„Ø¹Ø¨Ø© Ø¹Ù„Ù‰ Ø®Ø§Ø¯Ù… ÙˆÙŠØ¨ ÙˆÙ„ÙŠØ³ Ø§Ù„ØªØ´ØºÙŠÙ„ Ù…Ø­Ù„ÙŠÙ‹Ø§.</li>
      </ul>
      <button onclick="closeHelp()">Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„ØªØ¹Ù„ÙŠÙ…Ø§Øª</button>
    </div>
  </div>

  <!-- Ø¹Ù†ØµØ± Ø§Ù„Ù…ÙˆØ³ÙŠÙ‚Ù‰ Ø§Ù„Ø®Ù„ÙÙŠØ© (ÙŠÙ…ÙƒÙ† Ø§Ø³ØªØ¨Ø¯Ø§Ù„Ù‡ Ø¨Ù…Ù„Ù Ù…ÙˆØ³ÙŠÙ‚ÙŠ Ø­Ù‚ÙŠÙ‚ÙŠ) -->
  <audio id="bgMusic" loop src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAESsAACJWAAACABAAZGF0YQcAAAAA//8="></audio>

  <script>
    /***********************
     * Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© ÙˆØ­Ø§Ù„Ø© Ø§Ù„Ù„Ø¹Ø¨Ø©
     ***********************/
    let boardState = getInitialBoard();
    let boardCells = []; // Ù„ØªØ®Ø²ÙŠÙ† Ø®Ù„Ø§ÙŠØ§ Ø§Ù„Ù„ÙˆØ­Ø©
    let currentPlayer = 'white';
    let whiteTime = 300; // 5 Ø¯Ù‚Ø§Ø¦Ù‚
    let blackTime = 300;
    let timerInterval;
    let validMoves = [];
    let selectedCell = null;
    let lastMove = null; // Ù„ØªØ®Ø²ÙŠÙ† Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø³Ø§Ø¨Ù‚Ø© (Ù„Ù„ØªØ±Ø§Ø¬Ø¹)
    let moveHistory = []; // Ø³Ø¬Ù„ Ø§Ù„Ø­Ø±ÙƒØ§Øª

    let whitePlayerName = "Ù…ØµØ·ÙÙ‰";
    let blackPlayerName = "Ù„Ø§Ø¹Ø¨ 2";
    let soundEnabled = true;
    let musicEnabled = true;
    let darkTheme = true; // Ø§Ù„Ø«ÙŠÙ… Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ Ø¯Ø§ÙƒÙ†

    // ØªØªØ¨Ø¹ Ø­Ø±ÙƒØ© Ø§Ù„Ù…Ù„Ùƒ ÙˆØ§Ù„Ù‚Ù„Ø¹Ø§Øª Ù„Ù„ØªØ¨ÙŠÙŠØª
    let whiteKingMoved = false, blackKingMoved = false;
    let whiteRookMoved = { kingside: false, queenside: false };
    let blackRookMoved = { kingside: false, queenside: false };

    /***********************
     * Ø¯Ø¹Ù… ØªØ«Ø¨ÙŠØª Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ (PWA)
     ***********************/
    let deferredPrompt;
    window.addEventListener('beforeinstallprompt', (e) => {
      e.preventDefault();
      deferredPrompt = e;
      document.getElementById('installButton').style.display = 'inline-block';
    });
    function installApp() {
      if(deferredPrompt){
        deferredPrompt.prompt();
        deferredPrompt.userChoice.then((choiceResult) => {
          if(choiceResult.outcome === 'accepted')
            console.log('ØªÙ… Ù‚Ø¨ÙˆÙ„ Ø§Ù„ØªØ«Ø¨ÙŠØª');
          else
            console.log('ØªÙ… Ø±ÙØ¶ Ø§Ù„ØªØ«Ø¨ÙŠØª');
          deferredPrompt = null;
          document.getElementById('installButton').style.display = 'none';
        });
      } else {
        alert("Ù…ÙŠØ²Ø© Ø§Ù„ØªØ«Ø¨ÙŠØª Ù…ØªÙˆÙØ±Ø© Ø¹Ù†Ø¯ Ø±ÙØ¹ Ø§Ù„Ù„Ø¹Ø¨Ø© Ø¹Ù„Ù‰ Ø®Ø§Ø¯Ù… ÙˆÙŠØ¨ Ø­Ù‚ÙŠÙ‚ÙŠ.");
      }
    }

    /***********************
     * Ø¥Ù†Ø´Ø§Ø¡ ÙˆØªØ­Ø¯ÙŠØ« Ø§Ù„Ù„ÙˆØ­Ø©
     ***********************/
    function getInitialBoard() {
      return [
        ['â™œ','â™','â™','â™›','â™š','â™','â™','â™œ'],
        ['â™Ÿ','â™Ÿ','â™Ÿ','â™Ÿ','â™Ÿ','â™Ÿ','â™Ÿ','â™Ÿ'],
        ['','','','','','','',''],
        ['','','','','','','',''],
        ['','','','','','','',''],
        ['','','','','','','',''],
        ['â™™','â™™','â™™','â™™','â™™','â™™','â™™','â™™'],
        ['â™–','â™˜','â™—','â™•','â™”','â™—','â™˜','â™–']
      ];
    }
    function initializeBoard() {
      const board = document.getElementById('board');
      board.innerHTML = '';
      boardCells = [];
      for(let i = 0; i < 8; i++){
        boardCells[i] = [];
        for(let j = 0; j < 8; j++){
          const cell = document.createElement('div');
          cell.className = `cell ${(i+j)%2===0?'white':'black'}`;
          cell.dataset.row = i;
          cell.dataset.col = j;
          cell.addEventListener('click', handleCellClick);
          board.appendChild(cell);
          boardCells[i][j] = cell;
        }
      }
    }
    function updateBoard() {
      for(let i = 0; i < 8; i++){
        for(let j = 0; j < 8; j++){
          const cell = boardCells[i][j];
          cell.textContent = boardState[i][j];
          cell.className = `cell ${(i+j)%2===0?'white':'black'}`;
          if(validMoves.some(move => move.row === i && move.col === j)){
            cell.classList.add('valid-move');
          }
          if(selectedCell && parseInt(selectedCell.dataset.row) === i && parseInt(selectedCell.dataset.col) === j){
            cell.classList.add('selected');
          }
          // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ù„Ùƒ ÙÙŠ Ø­Ø§Ù„Ø© ÙƒØ´ØŒ Ø¥Ø¶Ø§ÙØ© ØªØ£Ø«ÙŠØ± Ø¶ÙˆØ¦ÙŠ
          if((boardState[i][j] === 'â™”' && currentPlayer === 'white' && isKingInCheck(boardState, 'white')) ||
             (boardState[i][j] === 'â™š' && currentPlayer === 'black' && isKingInCheck(boardState, 'black'))){
            cell.style.boxShadow = "0 0 10px 3px red";
          } else {
            cell.style.boxShadow = "none";
          }
        }
      }
      updateTurnIndicator();
      updateTimer();
      updateMoveHistory();
    }

    /***********************
     * Ø§Ù„Ù…Ø¤Ù‚Øª ÙˆØ¹Ø±Ø¶ Ø§Ù„Ø¯ÙˆØ± ÙˆØ´Ø±ÙŠØ· Ø§Ù„ØªÙ‚Ø¯Ù…
     ***********************/
    function startTimer() {
      clearInterval(timerInterval);
      timerInterval = setInterval(() => {
        if(currentPlayer === 'white') whiteTime--; else blackTime--;
        updateTimer();
        if(whiteTime <= 0 || blackTime <= 0){
          clearInterval(timerInterval);
          const winner = whiteTime <= 0 ? blackPlayerName : whitePlayerName;
          alert("Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„ÙˆÙ‚Øª! ÙØ§Ø² " + winner);
          resetGame();
        }
      }, 1000);
    }
    function formatTime(time) {
      const minutes = Math.floor(time / 60);
      const seconds = time % 60;
      return `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
    }
    function updateTimer() {
      document.getElementById('timer').textContent =
        `â³ ÙˆÙ‚Øª ${whitePlayerName}: ${formatTime(whiteTime)} | ÙˆÙ‚Øª ${blackPlayerName}: ${formatTime(blackTime)}`;
      const totalTime = 300;
      const currentTime = currentPlayer === 'white' ? whiteTime : blackTime;
      const percentage = (currentTime / totalTime) * 100;
      document.getElementById('timerProgress').style.width = percentage + '%';
    }
    function updateTurnIndicator() {
      const indicator = document.getElementById('turnIndicator');
      const currentName = currentPlayer === 'white' ? whitePlayerName : blackPlayerName;
      indicator.textContent = "Ø¯ÙˆØ±: " + currentName;
    }

    /***********************
     * Ø³Ø¬Ù„ Ø§Ù„Ø­Ø±ÙƒØ§Øª
     ***********************/
    function updateMoveHistory() {
      const historyDiv = document.getElementById('moveHistory');
      historyDiv.innerHTML = "";
      moveHistory.forEach((move, index) => {
        const p = document.createElement('p');
        p.textContent = `${index + 1}. ${move}`;
        historyDiv.appendChild(p);
      });
    }
    function addMoveToHistory(moveNotation) {
      moveHistory.push(moveNotation);
    }

    /***********************
     * ØªØ´ØºÙŠÙ„ Ø§Ù„Ø£ØµÙˆØ§Øª ÙˆØ§Ù„Ù…ÙˆØ³ÙŠÙ‚Ù‰
     ***********************/
    function playSound(frequency, duration) {
      if(!soundEnabled) return;
      try {
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        oscillator.type = 'sine';
        oscillator.frequency.value = frequency;
        oscillator.start();
        gainNode.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + duration);
        oscillator.stop(audioCtx.currentTime + duration);
      } catch(e) {
        console.log("Web Audio API ØºÙŠØ± Ù…Ø¯Ø¹ÙˆÙ…");
      }
    }
    function playSelectSound() { playSound(600, 0.1); }
    function playMoveSound() { playSound(400, 0.1); }
    function toggleSound() {
      soundEnabled = !soundEnabled;
      document.getElementById('soundToggle').textContent = "ØµÙˆØª: " + (soundEnabled ? "ØªØ´ØºÙŠÙ„" : "Ø¥ÙŠÙ‚Ø§Ù");
    }
    function toggleMusic() {
      musicEnabled = !musicEnabled;
      const bgMusic = document.getElementById('bgMusic');
      if(musicEnabled) { bgMusic.play(); document.getElementById('musicToggle').textContent = "Ù…ÙˆØ³ÙŠÙ‚Ù‰: ØªØ´ØºÙŠÙ„"; }
      else { bgMusic.pause(); document.getElementById('musicToggle').textContent = "Ù…ÙˆØ³ÙŠÙ‚Ù‰: Ø¥ÙŠÙ‚Ø§Ù"; }
    }
    function toggleTheme() {
      darkTheme = !darkTheme;
      if(darkTheme) {
        document.body.style.background = "linear-gradient(135deg, #2d2d2d, #1a1a1a)";
        document.getElementById('themeToggle').textContent = "Ø«ÙŠÙ…: Ø¯Ø§ÙƒÙ†";
      } else {
        document.body.style.background = "linear-gradient(135deg, #f5f7fa, #c3cfe2)";
        document.getElementById('themeToggle').textContent = "Ø«ÙŠÙ…: ÙØ§ØªØ­";
      }
    }

    /***********************
     * Ø¯ÙˆØ§Ù„ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù‚Ø·Ø¹
     ***********************/
    function isWhite(piece) {
      return ['â™”','â™•','â™–','â™—','â™˜','â™™'].includes(piece);
    }
    function isBlack(piece) {
      return ['â™š','â™›','â™œ','â™','â™','â™Ÿ'].includes(piece);
    }
    function isEnemy(currentPiece, targetPiece) {
      if(!targetPiece) return false;
      if(isWhite(currentPiece) && isBlack(targetPiece)) return true;
      if(isBlack(currentPiece) && isWhite(targetPiece)) return true;
      return false;
    }

    /***********************
     * Ø¯ÙˆØ§Ù„ Ø§Ù„Ù†Ø³Ø® ÙˆØ§Ù„Ù…Ø­Ø§ÙƒØ§Ø©
     ***********************/
    function deepCopyBoard(board) {
      return board.map(row => row.slice());
    }
    function simulateMove(board, fromRow, fromCol, move) {
      const piece = board[fromRow][fromCol];
      board[fromRow][fromCol] = '';
      board[move.row][move.col] = piece;
      if(move.castling){
        if(piece==='â™”'){
          if(move.castling==='kingside'){ board[7][7] = ''; board[7][5] = 'â™–'; }
          else if(move.castling==='queenside'){ board[7][0] = ''; board[7][3] = 'â™–'; }
        } else if(piece==='â™š'){
          if(move.castling==='kingside'){ board[0][7] = ''; board[0][5] = 'â™œ'; }
          else if(move.castling==='queenside'){ board[0][0] = ''; board[0][3] = 'â™œ'; }
        }
      }
    }

    /***********************
     * Ø§Ù„Ø­Ø±ÙƒØ§Øª Ø§Ù„Ù‚Ø§Ù†ÙˆÙ†ÙŠØ© ÙˆØ§Ù„ØªØ¨ÙŠÙŠØª
     ***********************/
    function getPseudoLegalMoves(board, row, col, piece) {
      let moves = [];
      if(piece==='â™™' || piece==='â™Ÿ'){
        const isPieceWhite = (piece==='â™™');
        const direction = isPieceWhite ? -1 : 1;
        const startRow = isPieceWhite ? 6 : 1;
        if(board[row+direction] && board[row+direction][col]===''){
          moves.push({row: row+direction, col: col});
          if(row===startRow && board[row+2*direction] && board[row+2*direction][col]==='')
            moves.push({row: row+2*direction, col: col});
        }
        for(let dc of [-1,1]){
          const targetRow = row+direction, targetCol = col+dc;
          if(board[targetRow] && board[targetRow][targetCol]!=='' && isEnemy(piece, board[targetRow][targetCol]))
            moves.push({row: targetRow, col: targetCol});
        }
      } else if(piece==='â™–' || piece==='â™œ'){
        const directions = [[-1,0],[1,0],[0,-1],[0,1]];
        directions.forEach(dir => {
          let r = row+dir[0], c = col+dir[1];
          while(r>=0 && r<8 && c>=0 && c<8){
            if(board[r][c]==='') { moves.push({row: r, col: c}); }
            else if(isEnemy(piece, board[r][c])) { moves.push({row: r, col: c}); break; }
            else break;
            r += dir[0]; c += dir[1];
          }
        });
      } else if(piece==='â™˜' || piece==='â™'){
        const knightMoves = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
        knightMoves.forEach(offset => {
          const r = row+offset[0], c = col+offset[1];
          if(r>=0 && r<8 && c>=0 && c<8 && (board[r][c]==='' || isEnemy(piece, board[r][c])))
            moves.push({row: r, col: c});
        });
      } else if(piece==='â™—' || piece==='â™'){
        const directions = [[-1,-1],[-1,1],[1,-1],[1,1]];
        directions.forEach(dir => {
          let r = row+dir[0], c = col+dir[1];
          while(r>=0 && r<8 && c>=0 && c<8){
            if(board[r][c]==='') { moves.push({row: r, col: c}); }
            else if(isEnemy(piece, board[r][c])) { moves.push({row: r, col: c}); break; }
            else break;
            r += dir[0]; c += dir[1];
          }
        });
      } else if(piece==='â™•' || piece==='â™›'){
        const rookDirs = [[-1,0],[1,0],[0,-1],[0,1]];
        rookDirs.forEach(dir => {
          let r = row+dir[0], c = col+dir[1];
          while(r>=0 && r<8 && c>=0 && c<8){
            if(board[r][c]==='') { moves.push({row: r, col: c}); }
            else if(isEnemy(piece, board[r][c])) { moves.push({row: r, col: c}); break; }
            else break;
            r += dir[0]; c += dir[1];
          }
        });
        const bishopDirs = [[-1,-1],[-1,1],[1,-1],[1,1]];
        bishopDirs.forEach(dir => {
          let r = row+dir[0], c = col+dir[1];
          while(r>=0 && r<8 && c>=0 && c<8){
            if(board[r][c]==='') { moves.push({row: r, col: c}); }
            else if(isEnemy(piece, board[r][c])) { moves.push({row: r, col: c}); break; }
            else break;
            r += dir[0]; c += dir[1];
          }
        });
      } else if(piece==='â™”' || piece==='â™š'){
        for(let dr=-1; dr<=1; dr++){
          for(let dc=-1; dc<=1; dc++){
            if(dr===0 && dc===0) continue;
            let r = row+dr, c = col+dc;
            if(r>=0 && r<8 && c>=0 && c<8 && (board[r][c]==='' || isEnemy(piece, board[r][c])))
              moves.push({row: r, col: c});
          }
        }
        // Ø­Ø±ÙƒØ© Ø§Ù„ØªØ¨ÙŠÙŠØª
        if(piece==='â™”' && row===7 && col===4 && !whiteKingMoved){
          if(board[7][5]==='' && board[7][6]==='' && board[7][7]==='â™–' && !whiteRookMoved.kingside)
            if(!isSquareAttacked(board,7,4,'black') && !isSquareAttacked(board,7,5,'black') && !isSquareAttacked(board,7,6,'black'))
              moves.push({row:7, col:6, castling:'kingside'});
          if(board[7][1]==='' && board[7][2]==='' && board[7][3]==='' && board[7][0]==='â™–' && !whiteRookMoved.queenside)
            if(!isSquareAttacked(board,7,4,'black') && !isSquareAttacked(board,7,3,'black') && !isSquareAttacked(board,7,2,'black'))
              moves.push({row:7, col:2, castling:'queenside'});
        } else if(piece==='â™š' && row===0 && col===4 && !blackKingMoved){
          if(board[0][5]==='' && board[0][6]==='' && board[0][7]==='â™œ' && !blackRookMoved.kingside)
            if(!isSquareAttacked(board,0,4,'white') && !isSquareAttacked(board,0,5,'white') && !isSquareAttacked(board,0,6,'white'))
              moves.push({row:0, col:6, castling:'kingside'});
          if(board[0][1]==='' && board[0][2]==='' && board[0][3]==='' && board[0][0]==='â™œ' && !blackRookMoved.queenside)
            if(!isSquareAttacked(board,0,4,'white') && !isSquareAttacked(board,0,3,'white') && !isSquareAttacked(board,0,2,'white'))
              moves.push({row:0, col:2, castling:'queenside'});
        }
      }
      return moves;
    }
    function getLegalMoves(row, col, piece) {
      const pseudoMoves = getPseudoLegalMoves(boardState, row, col, piece);
      let legalMoves = [];
      for(let move of pseudoMoves){
        let boardCopy = deepCopyBoard(boardState);
        simulateMove(boardCopy, row, col, move);
        if(!isKingInCheck(boardCopy, currentPlayer))
          legalMoves.push(move);
      }
      return legalMoves;
    }

    /***********************
     * Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØªØ¹Ø±Ø¶ Ù„Ù„ÙƒØ´
     ***********************/
    function isKingInCheck(board, color) {
      let kingSymbol = color==='white' ? 'â™”' : 'â™š';
      let kingPos = null;
      for(let i=0; i<8; i++){
        for(let j=0; j<8; j++){
          if(board[i][j]===kingSymbol){ kingPos = {row:i, col:j}; break; }
        }
        if(kingPos) break;
      }
      if(!kingPos) return true;
      let attackerColor = color==='white' ? 'black' : 'white';
      return isSquareAttacked(board, kingPos.row, kingPos.col, attackerColor);
    }
    function isSquareAttacked(board, row, col, attackerColor) {
      for(let i=0; i<8; i++){
        for(let j=0; j<8; j++){
          let piece = board[i][j];
          if(piece!=='' && ((attackerColor==='white' && isWhite(piece)) || (attackerColor==='black' && isBlack(piece)))){
            let moves = getPseudoLegalMoves(board, i, j, piece);
            if(piece==='â™”' || piece==='â™š')
              moves = moves.filter(m=>!m.castling);
            for(let move of moves){
              if(move.row===row && move.col===col)
                return true;
            }
          }
        }
      }
      return false;
    }
    function checkForCheckmate(color) {
      for(let i=0; i<8; i++){
        for(let j=0; j<8; j++){
          let piece = boardState[i][j];
          if(piece!=='' && ((color==='white' && isWhite(piece)) || (color==='black' && isBlack(piece)))){
            let moves = getLegalMoves(i, j, piece);
            if(moves.length > 0) return false;
          }
        }
      }
      if(isKingInCheck(boardState, color)) return true;
      return false;
    }

    /***********************
     * Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ù†Ù‚Ø± Ø§Ù„Ø®Ù„ÙŠØ©
     ***********************/
    function handleCellClick(e) {
      const cell = e.currentTarget;
      const row = parseInt(cell.dataset.row);
      const col = parseInt(cell.dataset.col);
      const piece = boardState[row][col];
      if(selectedCell){
        const selRow = parseInt(selectedCell.dataset.row);
        const selCol = parseInt(selectedCell.dataset.col);
        if(selRow === row && selCol === col){
          selectedCell = null;
          validMoves = [];
          updateBoard();
          return;
        }
        if(piece !== '' && ((currentPlayer==='white' && isWhite(piece)) || (currentPlayer==='black' && isBlack(piece)))){
          selectedCell = cell;
          validMoves = getLegalMoves(row, col, piece);
          playSelectSound();
          updateBoard();
          return;
        }
        if(validMoves.some(move => move.row === row && move.col === col)){
          lastMove = {
            boardState: deepCopyBoard(boardState),
            currentPlayer: currentPlayer,
            whiteTime: whiteTime,
            blackTime: blackTime,
            moveHistory: [...moveHistory]
          };
          const movingPiece = boardState[selRow][selCol];
          const chosenMove = validMoves.find(move => move.row === row && move.col === col);
          boardState[selRow][selCol] = '';
          boardState[row][col] = movingPiece;
          if(chosenMove.castling){
            if(movingPiece === 'â™”'){
              if(chosenMove.castling === 'kingside'){ boardState[7][7] = ''; boardState[7][5] = 'â™–'; }
              else if(chosenMove.castling === 'queenside'){ boardState[7][0] = ''; boardState[7][3] = 'â™–'; }
            } else if(movingPiece === 'â™š'){
              if(chosenMove.castling === 'kingside'){ boardState[0][7] = ''; boardState[0][5] = 'â™œ'; }
              else if(chosenMove.castling === 'queenside'){ boardState[0][0] = ''; boardState[0][3] = 'â™œ'; }
            }
          }
          let moveNotation = `${movingPiece} Ù…Ù† ${String.fromCharCode(65+selCol)}${8-selRow} Ø¥Ù„Ù‰ ${String.fromCharCode(65+col)}${8-row}`;
          if(chosenMove.castling) moveNotation += " (ØªØ¨ÙŠÙŠØª)";
          addMoveToHistory(moveNotation);
          playMoveSound();
          updateMovedFlags(selRow, selCol, movingPiece, chosenMove);
          currentPlayer = currentPlayer==='white' ? 'black' : 'white';
          selectedCell = null;
          validMoves = [];
          updateBoard();
          if(checkForCheckmate(currentPlayer)){
            let winner = currentPlayer==='white' ? blackPlayerName : whitePlayerName;
            alert("ÙƒØ´ Ù…Ù„Ùƒ! ÙØ§Ø² " + winner);
            resetGame();
          }
          return;
        }
        selectedCell = null;
        validMoves = [];
        updateBoard();
      } else {
        if(piece !== '' && ((currentPlayer==='white' && isWhite(piece)) || (currentPlayer==='black' && isBlack(piece)))){
          selectedCell = cell;
          validMoves = getLegalMoves(row, col, piece);
          playSelectSound();
          updateBoard();
        }
      }
    }

    /***********************
     * ØªØ­Ø¯ÙŠØ« Ø£Ø¹Ù„Ø§Ù… Ø§Ù„ØªØ¨ÙŠÙŠØª
     ***********************/
    function updateMovedFlags(fromRow, fromCol, piece, move) {
      if(piece === 'â™”'){
        if(currentPlayer === 'white') whiteKingMoved = true;
        else blackKingMoved = true;
      }
      if(piece === 'â™–'){
        if(currentPlayer === 'white'){
          if(fromRow === 7 && fromCol === 0) whiteRookMoved.queenside = true;
          if(fromRow === 7 && fromCol === 7) whiteRookMoved.kingside = true;
        }
      }
      if(piece === 'â™œ'){
        if(currentPlayer === 'black'){
          if(fromRow === 0 && fromCol === 0) blackRookMoved.queenside = true;
          if(fromRow === 0 && fromCol === 7) blackRookMoved.kingside = true;
        }
      }
      if(move.castling){
        if(piece === 'â™”'){
          if(move.castling === 'kingside') whiteRookMoved.kingside = true;
          else if(move.castling === 'queenside') whiteRookMoved.queenside = true;
        } else if(piece === 'â™š'){
          if(move.castling === 'kingside') blackRookMoved.kingside = true;
          else if(move.castling === 'queenside') blackRookMoved.queenside = true;
        }
      }
    }

    /***********************
     * Ø§Ù„ØªØ±Ø§Ø¬Ø¹ Ø¹Ù† Ø§Ù„Ø­Ø±ÙƒØ©
     ***********************/
    function undoMove() {
      if(lastMove){
        boardState = lastMove.boardState;
        currentPlayer = lastMove.currentPlayer;
        whiteTime = lastMove.whiteTime;
        blackTime = lastMove.blackTime;
        moveHistory = lastMove.moveHistory;
        selectedCell = null;
        validMoves = [];
        lastMove = null;
        updateBoard();
      }
    }

    /***********************
     * Ø´Ø§Ø´Ø© Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© ÙˆØ§Ù„Ù‚Ø§Ø¦Ù…Ø© ÙˆØ§Ù„ØªØ¹Ù„ÙŠÙ…Ø§Øª
     ***********************/
    function startGame() {
      const whiteInput = document.getElementById('whitePlayerNameInput').value.trim();
      const blackInput = document.getElementById('blackPlayerNameInput').value.trim();
      whitePlayerName = whiteInput !== '' ? whiteInput : "Ù…ØµØ·ÙÙ‰";
      blackPlayerName = blackInput !== '' ? blackInput : "Ù„Ø§Ø¹Ø¨ 2";
      document.getElementById('startScreen').style.display = 'none';
      resetGame();
    }
    function openMenu() { document.getElementById('menuScreen').style.display = 'flex'; }
    function closeMenu() { document.getElementById('menuScreen').style.display = 'none'; }
    function openHelp() { document.getElementById('helpScreen').style.display = 'flex'; }
    function closeHelp() { document.getElementById('helpScreen').style.display = 'none'; }

    /***********************
     * Ø¥Ø¹Ø§Ø¯Ø© ØªØ´ØºÙŠÙ„ Ø§Ù„Ù„Ø¹Ø¨Ø©
     ***********************/
    function resetGame() {
      whiteTime = 300;
      blackTime = 300;
      currentPlayer = 'white';
      boardState = getInitialBoard();
      selectedCell = null;
      validMoves = [];
      lastMove = null;
      moveHistory = [];
      whiteKingMoved = false; blackKingMoved = false;
      whiteRookMoved = { kingside: false, queenside: false };
      blackRookMoved = { kingside: false, queenside: false };
      startTimer();
      updateBoard();
    }

    /***********************
     * ØªØ³Ø¬ÙŠÙ„ Service Worker (PWA)
     ***********************/
    if('serviceWorker' in navigator){
      window.addEventListener('load', () => {
        const swCode = `
          self.addEventListener('install', event => { self.skipWaiting(); });
          self.addEventListener('fetch', event => { event.respondWith(fetch(event.request)); });
        `;
        const blob = new Blob([swCode], { type: 'text/javascript' });
        const swUrl = URL.createObjectURL(blob);
        navigator.serviceWorker.register(swUrl).then(reg => {
          console.log('ØªÙ… ØªØ³Ø¬ÙŠÙ„ Service Worker');
        }).catch(err => {
          console.log('ÙØ´Ù„ ØªØ³Ø¬ÙŠÙ„ Service Worker', err);
        });
      });
    }

    /***********************
     * Ø¹Ù†Ø¯ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙØ­Ø©
     ***********************/
    window.onload = function() {
      initializeBoard();
      updateBoard();
      updateTimer();
      updateTurnIndicator();
      if(musicEnabled) document.getElementById('bgMusic').play();
    }
  </script>
</body>
</html>
